# 计算机网络基础
#### 操作系统里如何调度
进程调度方式：<br/>
**非抢占式**<br/>
一旦处理机分配给某个进程后，就一直让其运行直到完成或者发生某事件而阻塞（如`I/O`请求）<br/>
**抢占式**<br/>
允许调度程序根据某种规则，暂停某个正在执行的进程，由以下规则：优先权原则：优先级高的抢占当前进程；短进程优先原则；时间片原则：各进程按时间片轮转运行时，当正在执行的进程的时间片用完后，便停止该进程的执行而重新进行调度。<br/>
#### 进程和线程的区别
进程是资源分配的最小单位，线程是程序执行的最小单位。<br/>
进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此`CPU`切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。<br/>
线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式`(IPC)`进行。不过如何处理好同步与互斥是编写多线程程序的难点。<br/>
但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
#### 计算机网络模型分层
 | 分层名称 | 功能概述 | 常见协议
-|-|-|-
7 | 应用层 | 针对特定应用的协议 | `FTP、DNS、HTTP、SMTP`等
6 | 表示层 | 负责数据格式的转换 | 不用协议
5 | 会话层 | 负责建立和断开通信连接 | 不用协议
4 | 传输层 | 负责可靠的数据传输 | `TCP、UDP`等
3 | 网络层 | 负责将数据传输到目标地址 | `ARP、IP、RARP`等
2 | 数据链路层 | 负责物理层面的互连，节点之间的通信传输 | `802.11、WIFI`等
1 | 物理层 | 负责物理电路的比特流互换传输 | `RS-443`等
 
 #### `http`在哪一层，`tcp`呢
`http`在应用层，`tcp`在传输层
#### 什么是`TCP/IP`
`TCP/IP` 指传输控制协议/网际协议 `(Transmission Control Protocol / Internet Protocol)`,是供已连接因特网的计算机进行通信的通信协议。定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。

#### `TCP`三次握手
1、客户端发送`syn`包到服务器，等待服务器确认接收。<br/>
2、服务器确认接收`syn`包并确认客户的`syn`，并发送回来一个`syn+ack`的包给客户端。<br/>
3、客户端确认接收服务器的`syn+ack`包，并向服务器发送确认包`ack`，二者相互建立联系后，完成`tcp`三次握手。

#### `TCP`四次挥手
1、客户端进程发出连接释放报文，并且停止发送数据。<br/>
2、服务器收到连接释放报文，发出确认报文，此时，服务端就进入了`CLOSE-WAIT`（关闭等待）状态。<br/>
3、客户端收到服务器的确认请求后，此时，客户端就进入`FIN-WAIT-2`（终止等待2）状态，等待服务器发送连接释放报文。<br/>
4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，此时，服务器就进入了`LAST-ACK`（最后确认）状态，等待客户端的确认。<br/>
5、客户端收到服务器的连接释放报文后，必须发出确认，此时，客户端就进入了`TIME-WAIT`（时间等待）状态。注意此时`TCP`连接还没有释放，必须经过`2∗∗MSL`（最长报文段寿命）的时间后，当客户端撤销相应的`TCB`后，才进入`CLOSED`状态。<br/>
6、服务器只要收到了客户端发出的确认，立即进入`CLOSED`状态。同样，撤销`TCB`后，就结束了这次的`TCP`连接。可以看到，服务器结束`TCP`连接的时间要比客户端早一些。

#### `TCP`与`UDP`的区别
`TCP`（`Transmission Control Protocol`，传输控制协议）提供的是面向连接，可靠的字节流服务。即客户和服务器交换数据前，必须现在双方之间建立一个`TCP`连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br/>
`UDP`（`User Data Protocol`，用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。<br/><br/>
1、`TCP`面向连接（如打电话要先拨号建立连接）;`UDP`是无连接的，即发送数据之前不需要建立连接。<br/>
2、`TCP`提供可靠的服务。也就是说，通过`TCP`连接传送的数据，无差错，不丢失，不重复，且按序到达;`UDP`尽最大努力交付，即不保证可靠交付。<br/>
3、`TCP`面向字节流，实际上是`TCP`把数据看成一连串无结构的字节流;`UDP`是面向报文的。`UDP`没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br/>
4、每一条`TCP`连接只能是点到点的;`UDP`支持一对一，一对多，多对一和多对多的交互通信。<br/>
5、`TCP`首部开销`20`字节;`UDP`的首部开销小，只有`8`个字节。<br/>
6、`TCP`的逻辑通信信道是全双工的可靠信道，`UDP`则是不可靠信道。

#### `Socket`
`socket`是一组实现`TCP/UDP`通信的接口`API`，既无论`TCP`还是`UDP`，通过对`scoket`的编程，都可以实现`TCP/UDP`通信。<br/>
`socket`作为一个通信链的句柄，它包含了网络通信必备的`5`种信息:<br/>
1、连接使用的协议。<br/>
2、本地主机的`IP`地址。<br/>
3、本地进程的协议端口。<br/>
4、远程主机的`IP`地址。<br/>
5、远程进程的协议端口。

#### `URL(Uniform Resource Locator)`统一资源定位符
`URL`的语法规则： `scheme：//host/domain:port/path/filename`<br/>
1、`scheme`：定义因特网服务的类型，最常见的有`http`。<br/>
2、`host`：定义域主机（`http`默认主机是`www`）。<br/>
3、`domain`：定义因特网域名，比如`“www.baidu.com”`。<br/>
4、`path`：定义服务器上的路径。<br/>
5、`filename`：资源名

#### `DNS(Domain Name Server)`域名服务器
在浏览器输入域名后的解析过程:<br/>
1、浏览器根据地址去本身缓存中查找`dns`解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（`hosts`文件）是否有该域名的`dns`解析记录，如果有则返回。<br/>
2、如果浏览器缓存和操作系统`hosts`中均无该域名的`dns`解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。<br/>
3、请求会先到`LDNS`（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析。<br/>
4、根域名服务器给`LDNS`返回一个所查询的主域名服务器`（gTLDServer）`地址。<br/>
5、此时`LDNS`再向上一步返回的`gTLD`服务器发起解析请求。<br/>
6、`gTLD`服务器接收到解析请求后查找并返回此域名对应的`Name Server`域名服务器的地址，这个`Name Server`通常就是你注册的域名服务器（比如阿里`dns`、腾讯`dns`等）。<br/>
7、`Name Server`域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标`IP`记录，连同一个`TTL`值返回给`DNS Server`域名服务器。<br/>
8、返回该域名对应的`IP`和`TTL`值，`Local DNS Server`会缓存这个域名和`IP`的对应关系，缓存的时间有`TTL`值控制。<br/>
9、把解析的结果返回给用户，用户根据`TTL`值缓存在本地系统缓存中，域名解析过程结束。

#### 用户输入`URL`到浏览器显现给用户页面经过了什么过程
1、用户输入`URL`，浏览器获取到`URL`<br/>
2、浏览器(应用层)进行`DNS`解析（直接输入`IP`地址既跳过该步骤）<br/>
3、根据解析出的`IP`地址+端口，浏览器（应用层）发起`HTTP`请求，请求中携带（请求头`header`、请求体`body`）<br/>
4、请求到达传输层，`tcp`协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输。<br/>
5、到网络层， 网络层通过`ARP`寻址得到接收方的`Mac`地址，`IP`协议把在传输层被分割成一个个数据包传送接收方。<br/>
6、数据到达数据链路层，请求阶段完成<br/>
7、接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得到请求报文。<br/>
8、接收方收到发送方的`HTTP`请求之后，进行请求文件资源（如`HTML`页面）的寻找并响应报文<br/>
9、发送方收到响应报文后，如果报文中的状态码表示请求成功，则接受返回的资源（如`HTML`文件），进行页面渲染。

详细升级版：<br/>
1.在浏览器地址栏输入URL <br/>
2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br/>
2.1 如果资源未缓存，发起新请求 <br/>
2.2 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。<br/> 
2.3 检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control<br/>
2.3.1 HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 2.3.2 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间<br/>
3.浏览器解析URL获取协议，主机，端口，path <br/>
4.浏览器组装一个HTTP（GET）请求报文 <br/>
5.浏览器获取主机ip地址，过程如下<br/>
5.1 浏览器缓存 <br/>
5.2 本机缓存 <br/>
5.3 hosts文件 <br/>
5.4 路由器缓存 <br/>
5.5 ISP DNS缓存 <br/>
5.6 DNS递归查询（可能存在负载均衡导致每次IP不一致）<br/>
6.打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：<br/>
6.1 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 <br/>
6.2 服务器发回SYN=1，ACK=x+1,Seq=Y的相应包 <br/>
6.3 客户端发送ACK=Y+1，Seq=z<br/>
7.TCP链接建立后发送HTTP请求 <br/>
8.服务器接收请求后解析，将请求转发到服务器程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 <br/>
9.服务器检测HTTP请求头是否包含缓存验证信息，如果验证缓存新鲜，返回304等对应状态 <br/>
10.出合理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作 <br/>
11.服务器将相应报文通过TCP链接发送回浏览器 12.浏览器接收HTTP相应，然后根据情况选择关闭TCP链接或者保留重用，关闭TCP链接的四次握手如下：<br/>
12.1 主动方发送Fin=1,ACK=z,Seq=x报文 <br/>
12.2 被动方发送ACK=X+1,Seq=Y报文 <br/>
12.3 被动方发送Fin=1,ACK=X,Seq=Y报文 <br/>
12.4 主动方发送ACK=Y,Seq=x 报文<br/>
13.浏览器检查相应状态码 <br/>
14.如果资源可缓存，进行缓存 <br/>
15.对相应进行解码 <br/>
16.根据资源类型决定如何处理 <br/>
17.解析HTML文档，构建DOM树，下载资源，构建CSSOM树，执行js脚本，这些操作每月严格的先后顺序 <br/>
18.构建DOM树：<br/>
18.1 Tokenizing：根据HTML规范将字符流解析为标记 <br/>
18.2 Lexing：词法分析将标记转换为对象并定义属性和规则 <br/>
18.3 DOM construction：根据HTML标记关系将对象组成DOM树<br/>
19.解析过程中遇到图片、样式表、js文件，启动下载 <br/>
20.构建CSSOM树：<br/>
20.1 Tokenizing：字符流转换为标记流 <br/>
20.2 Node：根据标记创建节点 <br/>
20.3 CSSOM：节点创建CSSOM树<br/>
根据DOM树和CSSOM树构建渲染树<br/>
21.1 从DOM树的根节点遍历所有可见节点，不可见节点包括：1） script , meta 这样本身不可见的标签。2)被css隐藏的节点，如 display: none <br/>
21.2 对每一个可见节点，找到恰当的CSSOM规则并应用 <br/>
21.3 发布可视节点的内容和计算样式<br/>
22.js解析如下<br/>
22.1 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading <br/>
22.2 HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 <br/>
22.3 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 <br/>
22.4 当文档完成解析，document.readState变成interactive <br/>
22.5 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() <br/>
22.6 浏览器在Document对象上触发DOMContentLoaded事件 <br/>
22.7 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件
23.显示页面（HTML解析过程中会逐步显示页面）<br/>



#### `HTTP`状态码
`2XX` 成功<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`200 OK`: 表示从客户端发来的请求在服务器端被正确处理<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`204 No content`: 表示请求成功，但响应报文不含实体的主体部分<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`206 Partial Content`: 进行范围请求<br/>
`3XX` 重定向<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`301 moved permanently`: 永久性重定向，表示资源已被分配了新的 `URL`<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`302 found`，临时性重定向: 表示资源临时被分配了新的 `URL`<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`303 see other`: 表示资源存在着另一个 `URL`，应使用 `GET` 方法定向获取资源<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`304 not modified`: 表示服务器允许访问资源，但因发生请求未满足条件的情况<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`307 temporary redirect`: 临时重定向，和`302`含义相同<br/>
`4XX` 客户端错误<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`400 bad request`: 请求报文存在语法错误<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`401 unauthorized`: 表示发送的请求需要有通过 `HTTP` 认证的认证信息<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`403 forbidden`: 表示对请求资源的访问被服务器拒绝<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`404 not found`: 表示在服务器上没有找到请求的资源<br/>
`5XX` 服务器错误<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`500 internal sever error`: 表示服务器端在执行请求时发生了错误<br/>
&nbsp;&nbsp;&nbsp;&nbsp;`502 bad gate way`: 产生错误的原因是连接超时<br>
&nbsp;&nbsp;&nbsp;&nbsp;`503 service unavailable`: 表明服务器暂时处于超负载或正在停机维护，无法处理请求<br/>
#### 永久性重定向`（301）`和临时性重定向`（302）`对` SEO `有什么影响
1）`301 redirect`——`301`代表永久性转移`(Permanently Moved)`，`301`重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用`301`来做转址。<br>
如果我们把一个地址采用`301`跳转方式跳转的话，搜索引擎会把老地址的`PageRank`等信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。旧网址的排名等完全清零<br>
2）`302 redirect`——`302`代表暂时性转移`(Temporarily Moved)`，在前些年，不少`Black Hat SEO`曾广泛应用这项技术作弊，目前，各大主要搜索引擎均加强了打击力度，象`Google`前些年对`Business.com`以及近来对`BMW`德国网站的惩罚。即使网站客观上不是`spam`，也很容易被搜寻引擎容易误判为`spam`而遭到惩罚。

#### `HTTP`协议格式
`HTTP`的请求和响应的消息协议是一样的，分为三个部分，起始行、消息头和消息体。这三个部分以`CRLF`作为分隔符。最后一个消息头有两个`CRLF`，用来表示消息头部的结束。<br/>
消息头部有很多键值对组成，多个键值对之间使用`CRLF`作为分隔符，也可以完全没有键值对。形如`Content-Encoding: gzip`
消息体是一个字符串，字符串的长度是由消息头部的`Content-Length`键指定的。如果没有`Content-Length`字段说明没有消息体，譬如`GET`请求就是没有消息体的，`POST`请求的消息体一般用来放置表单数据。`GET`请求的响应返回的页面内容也是放在消息体里面的。我们平时调用`API`返回的`JSON`内容都是放在消息体里面的。
#### `HTTP`的无状态性？
所谓`HTTP`协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在`HTTP`协议之上的应用程序就无法维持状态。应用层可以通过会话`Session`来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话`ID`，浏览器可以将会话`ID`记录在本地缓存`LocalStorage`或者`Cookie`，在后续的请求都带上这个会话`ID`，服务器就可以为每个请求找到相应的会话状态。
#### `http https`
1、`https`协议需要到`ca`申请证书，一般免费证书较少，因而需要一定费用。<br>
2、`http`是超文本传输协议，信息是明文传输，`https`则是具有安全性的`ssl`加密传输协议。<br>
3、`http`和`https`使用的是完全不同的连接方式，用的端口也不一样，前者是`80`，后者是`443`。<br>
4、`http`的连接很简单，是无状态的；`HTTPS`协议是由`SSL+HTTP`协议构建的可进行加密传输、身份认证的网络协议，比`http`协议安全。<br>

升级`https`: 购买、下载`SSL`证书、安装证书等
#### 简单讲解一下`http2`的多路复用
`HTTP2`采用二进制格式传输，取代了`HTTP1.x`的文本格式，二进制格式解析更高效。<br>
多路复用代替了`HTTP1.x`的序列和阻塞机制，所有的相同域名请求都通过同一个`TCP`连接并发完成。在`HTTP1.x`中，并发多个请求需要多个`TCP`连接，浏览器为了控制资源会有`6-8`个`TCP`连接都限制。<br>
`HTTP2`中同域名下所有通信都在单个连接上完成，消除了因多个`TCP`连接而带来的延时和内存消耗。 单个连接上可以并行交错的请求和响应，之间互不干扰。<br>

#### http1.0、1.1、2.0协议的区别？
`http 1.0` 构建可扩展<br>
`http 1.1` 添加了持久链接<br>
`http 2.0` 添加了加密 头部压缩 服务器推送 管线操作 以及多路复用等功能<br>

#### http请求头有哪些?
HTTP的头信息包括通用头、请求头、响应头和实体头四个部分<br/>
通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。<br/>
请求头标：允许客户端传递关于自身的信息和希望的响应形式。<br/>
响应头标：服务器和于传递自身信息的响应。<br/>
实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。<br/>

#### `Ajax`的作用 全称
`Ajax`主要实现页面和 `web` 服务器之间数据的异步传输。<br>
`Ajax` 即“`Asynchronous Javascript And XML`”（异步 `JavaScript` 和 `XML`），是指一种创建交互式网页应用的网页开发技术
#### `https` 的握手过程
第一步，客户端给出协议版本号、一个客户端生成的随机数`（Client random）`，以及客户端支持的加密方法。<br>
第二步，服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数`（Server random）`。<br>
第三步，客户端确认数字证书有效，然后生成一个新的随机数`（Premaster secret）`，并使用数字证书中的公钥，加密这个随机数，发给服务器。<br>
第四步，服务器使用自己的私钥，获取客户端发来的随机数（即`Premaster secret`）。<br>
第五步，客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"`（session key）`，用来加密接下来的整个对话过
程。

#### 客户端与服务端长连接的几种方式
ajax 轮询: ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。<br/>
long poll 长轮询: long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询<br/>
iframe 长连接: 在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。<br/>
WebSocket: Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。

#### WebSocket与 HTTP 的区别
URL是以 ws: 开头，如果是对应的 HTTPS，则以 wss: 开头。WebSocket 使用 ws 或 wss 为统一资源标志符，其中 wss 表示在 TLS 之上的 Websocket。<br/>
Status Code：101。该状态码表示协议切换。服务器返回了 101 ，表示没有释放 TCP 连接。WebSoket 协议握手阶段还是依赖于 HTTP 协议，到数据传输阶段便切换协议。<br/>
Conection：upgrade，表示协议升级。在 HTTP 协议中，该请求头有两个值，一个是 close ， HTTP/1.0 默认值，表示客户端或服务端想要关闭连接。另一个是 keep-alive，HTTP/1.1 默认值，表示长连接。<br/>
以下头部字段是只有 WebSocket 协议才有的字段。<br/>
请求头：<br/>
Sec-WebSocket-Extension：表示客户端协商的拓展特性。<br/>
Sec-WebSocket-Key：是一个 Base64 encode 的密文，由浏览器随机生成，用来验证是否是 WebSocket 协议。<br/>
Sec-WebSocket-Version：表示 WebSocket 协议版本。<br/>

响应头：<br/>
Sec-WebSocket-Extension：表示服务端支持的拓展特性。<br/>
Sec-WebSocket-Accept：与客户端的 Sec-WebSocket-Key 相对应，是经过服务器确认，加密过后的 Sec-WebSocket-Key。<br/>

优点：<br/>
双向通信。客户端和服务端双方都可以主动发起通讯。<br/>
没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。<br/>
数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。<br/>
传输效率高。因为只需要一次连接，所以数据传输效率高。<br/>
缺点：<br/>
长连接需要后端处理业务的代码更稳定，推送消息相对复杂；<br/>
长连接受网络限制比较大，需要处理好重连。<br/>
兼容性，WebSocket 只支持 IE10 及其以上版本。<br/>
服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；<br/>
成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决<br/>

#### 介绍下 `HTTPS` 中间人攻击
中间人攻击过程如下：<br>
1、服务器向客户端发送公钥。<br>
2、攻击者截获公钥，保留在自己手上。<br>
3、然后攻击者自己生成一个【伪造的】公钥，发给客户端。<br>
4、客户端收到伪造的公钥后，生成加密hash值发给服务器。<br>
5、攻击者获得加密hash值，用自己的私钥解密获得真秘钥。<br>
6、同时生成假的加密hash值，发给服务器。<br>
7、服务器用私钥解密获得假秘钥。<br>
8、服务器用假秘钥加密传输信息<br>

防范方法：<br>
服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性

#### `sql`注入
就是通过把`SQL`命令插入到`Web`表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的`SQL`命令。

总的来说有以下几点：<br>
1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。<br>
2.永远不要使用动态拼装`SQL`，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取。<br>
3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。<br>
4.不要把机密信息明文存放，请加密或者`hash`掉密码和敏感的信息。<br>
#### `XSS`原理及防范
`Xss(cross-site scripting)`攻击指的是攻击者往`Web`页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，
当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。<br>

**防范:**<br>
1）输入。<br>
在提交表单时，前端最好将文本内容转为`html`实体编码，也就是过滤掉`<script>、<a>`、这样的内容，然后再提交到后台去。当然保险起见，后台也要再做一遍`html`实体转码，然后再入库。<br>
2）输出。<br>
在显示文本内容时，最好也要做一次`html`实体编码转换后再显示，防止`<script>`标签生效。


`XSS` 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。<br>
`XSS`攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。<br>
反射型 `XSS` 的攻击步骤：<br>
攻击者构造出特殊的 `URL`，其中包含恶意代码。<br>
用户打开带有恶意代码的 `URL` 时，网站服务端将恶意代码从 `URL` 中取出，拼接在 `HTML` 中返回给浏览器。<br>
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。<br>

**反射型**<br>
反射型 `XSS` 漏洞常见于通过 `URL` 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 `URL` 才能生效，攻击者往往会结合多种手段诱导用户点击。<br>

如何防范反射型`XSS`攻击
```js
// 对url的查询参数进行转义后再输出到页面。
app.get('/welcome', function(req, res) {
    //对查询参数进行编码，避免反射型 XSS攻击
    res.send(`${encodeURIComponent(req.query.type)}`); 
});
```

**DOM 型 XSS**<br>
`DOM` 型 `XSS` 攻击，实际上就是前端 `JavaScript` 代码不够严谨，把不可信的内容插入到了页面。在使用 `.innerHTML、.outerHTML、.appendChild、document.write()`等`API`时要特别小心，不要把不可信的数据作为 `HTML` 插到页面上，尽量使用 `.innerText、.textContent、.setAttribute()` 等。<br>

`DOM` 型 `XSS` 的攻击步骤：<br>
攻击者构造出特殊数据，其中包含恶意代码。<br>
用户浏览器执行了恶意代码。<br>
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。<br>

如何防范 `DOM` 型 `XSS`攻击<br>
防范 `DOM` 型 `XSS` 攻击的核心就是对输入内容进行转义(`DOM` 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。

**存储型XSS**<br>
恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。<br>

存储型 `XSS` 的攻击步骤：<br>
击者将恶意代码提交到目标网站的数据库中。<br>
用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 `HTML` 中返回给浏览器。<br>
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。<br>

如何防范存储型`XSS`攻击：<br>
前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)<br>
服务器接收到数据，在存储到数据库之前，进行转义/过滤<br>
前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤<br>

#### CSRF
`CSRF（Cross-site request forgery`跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。<br>

典型的`CSRF`攻击流程：<br>
受害者登录`A`站点，并保留了登录凭证`（Cookie）`。<br>
攻击者诱导受害者访问了站点`B`。<br>
站点`B`向站点`A`发送了一个请求，浏览器会默认携带站点`A`的`Cookie`信息。<br>
站点`A`接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。<br>
站点`A`以受害者的名义执行了站点`B`的请求。<br>
攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击<br>

`CSRF` 攻击防御<br>
1、添加验证码(体验不好)
2、 判断请求的来源：检测`Referer`(并不安全，`Referer`可以被更改)
3、使用`Token`(主流)










